<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
	</head>
	<body>

	</body>
	
	<script type="text/javascript">
		
		//prototype 可以向对象添加属性和方法
		
		// function employee(name,job,born){
		// 	this.name=name;
		// 	this.job=job;
		// 	this.born=born;
		// }
		// var bill=new employee("Bill Gates","Engineer",1985);
		// employee.prototype.salary=null;
		// bill.salary=20000;
		// document.write(bill.salary);
		// console.log(bill)
		
		// /* Array.prototype对象和Object.prototype对象分别的属性和方法。 */
		// console.log(Object.getOwnPropertyNames(Array.prototype))
		// console.log(Object.getOwnPropertyNames(Object.prototype))
		
		
		//读取原型链的constructor属性
		// constructor 属性返回对创建此对象的数组函数的引用。
		
		// function A(name, job, age) {
		// 	this.name = name;
		// 	this.job = job;
		// 	this.age = age;
		// };
		// var a = new A('zhangsan', 'work', 18);
		// console.log(a.constructor);
		// console.log(a.constructor === A.prototype.constructor);
		
		//分辨原型对象到底属于那个构造函数
		// function A(){};
		// var a = new A();
		// console.log(a.constructor === A) // true
		// console.log(a.constructor === Array) // false
		
		//从实例创建另一个实例
		
		// instanceof 是 Java 的一个二元操作符，类似于 ==，>，< 等操作符。
		// instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。
		// function A(){};
		// var a = new A();
		// var b = new a.constructor();
		// console.log(b instanceof A);	
		
		// 调用自身的构造函数成为可能
		// A.prototype.hello = function(){
		// 	return new this.constructor();
		// }
		// console.log(A.constructor())
		//提供了一种从构造函数继承另外一种构造函数的模式
		// function Father() {};
		// function Son(){
		// 	Son.height.constructor.call(this);
		// }
		// Son.height = new Father();
		// console.log(Son.height)
		//以上 father和son都是构造函数,在son内部的this调用father就会形成son继承father的效果
		
		//constructor属性是一种原型对象和构造函数的关系,所以修改原型对象时,要注意constructor的指向问题
		// 解决方法:
				// 1.将constructor属性指向原来的构造函数
				// 2.只在原型对象上添加属性和方法,避免instanceof失真
	</script>
	
</html>
